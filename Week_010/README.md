# 毕业总结

## 数组、链表、跳表

1. 数组是有限个相同类型的变量存储在连续内存中的数据结构。数组的访问时间复杂度为 O(1)，搜索、插入、删除的时间复杂度为 O(n)。
2. 链表可以储存在不连续的内存中，每个节点除了保存自身的值外，还保存下一个节点的地址，形成链式结构。链表的访问、搜索时间复杂度为 O(1)，插入、删除的时间复杂度为 O(n)。
3. 跳表是针对有序链表的缺点，通过空间换时间的方式，进行升维，形成跳表结构，从而优化链表的搜索时间复杂度。

## 栈、队列、优先队列、双端队列

1. 栈：先入先出，添加和删除的时间复杂度都是 O(1)。
2. 队列：先入后出，添加和删除的时间复杂度都是 O(1)。
3. 优先队列：插入操作时间复杂度是 O(1)，取出是因为要考虑元素的优先级，复杂度是 O(log n)。
4. 双端队列：两端都可以进/出的队列，可以作为普通的队列/栈使用。

## 哈希表、映射、集合

哈希表，也叫散列表，用于存放键值对。通过哈希函数对键计算其哈希值，根据哈希值将数据存放在数据结构中，加快查找速度。

## 树、二叉树、二叉搜索树

树包含一个根结点，及其若干个子节点。每个子节点也包含它自己的若干个子节点。

- 如果树的每个节点都最多包涵一个子节点，就是链表。
- 如果每个节点都最多包涵两个子节点的树，叫做二叉树。
- 可以通过深度优先搜索对树进行前/中/后序遍历。
- 可以通过广度优先搜索对树进行层级遍历。

二叉搜索树也叫二叉排序树，它有以下特征：

- 左子树上所有节点的值小于根结点的值。
- 右子树上所有节点的值大于根结点的值。
- 左右子树也具有以上性质。

二叉排序树的中序遍历是一个升序排列。

## 堆、二叉堆、图

堆是一个可以迅速找到最大值和最小值的数据结构，它是一个接口，有多种实现方式，比如二叉树、数组等。

二叉堆通过完全二叉树实现（底层是一个数组），它具有以下性质：

- 是一颗完全二叉树
- 树中任意节点的值都大于等于/小于等于其两个子节点的值。

图由节点和节点之间的引用关系组成。如果一个图中没有循环引用的节点，那么就变成了一个树（树是特殊的图，链表是特殊的树）。由于可能存在循环引用，在进行图的深度优先搜索和广度优先搜索时，需要记录已访问的节点。

## 泛型递归、树递归

递归就是函数调用自己，是通过函数体来进行的循环。

``` java
public void recursive(int level, int param) {
    // 递归终止条件
    if (level > MAX_LEVEL) {
        // 返回当前层结果
        return; 
    }
    // 执行当前层的逻辑
    process(level, param);
    // 调用下一层递归
    recursive(level + 1, newParam);
    // 还原当前层状态
}
```

## 分治、回溯

分治和回溯本质上都是递归，它们是两种解题思路。

- 分治是指将复杂问题拆解成子问题
- 回溯是指通过递归试错找到正确的解

## 深度优先搜索、广度优先搜索

遍历搜索，是在图/树中通过遍历所有的节点，寻找特定的节点。特点是每个节点都要访问一次，且只访问一次。根据对节点的访问顺序不同，分为：

- 深度优先搜索（Depth First Search，DFS）
- 广度优先搜索（Breadth First Search，BFS）

深度优先搜索：

 ``` java
class Solution {
    List<Integer> result = new ArrayList<>();
    Set<Node> visited = new HashSet<>();
    public List<Integer> dfs(Node node) {
        if (node != null && !visited.contains(node)) {
            visited.add(node);
            result.add(node.val);
            for (Node child : node.children) {
                dfs(child);
            }
        }
        return result;
    }
}
 ```

广度优先搜索：

``` java
class Solution {
    List<Integer> result = new ArrayList<>();
    Set<Node> visited = new HashSet<>();
    public List<Integer> dfs(Node node) {
        Queue<Node> queue = new LinkedList<>();
        if (node != null) {
            queue.add(node);
        }
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node curr = queue.poll();
                if (visited.contains(curr)) {
                    continue;
                }
                result.add(curr.val);
                visited.add(curr);
                queue.addAll(curr.children);
            }
        }
        return result;
    }
}
```

## 贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最有的算则，从而导致结果是全剧最优的算法。

贪心算法和动态规划的区别：

- 贪心算法对每一个子问题的解决方案都做出选择不能回退
- 动态规划会保存以前的运算结果，并根据之前结果对当前进行算则，可以回退。

使用贪心算法的条件是：问题可以分解成子问题来解决，并且子问题的最优解能递推到最终问题的最优解。这种子问题最优解也称为最优子结构。

## 二分查找

使用二分查找需要满足三个条件：

- 目标函数单调性（单调递增或递减）。
- 存在上下边界。
- 能够通过索引访问。

``` java
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
    while (left <= right) {
        mid = (right - left) / 2 + left;
        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```

## 动态规划

动态规划与分治、回溯、递归，本质上都是通过找到重复的子问题，来解决问题。

## 字典树、并查集

字典树，即 Trie 树，又称单词查找树或键树，是一种树结构。典型应用是用于统计和排序大量的字符串，经常被搜索引擎系统用于文本词频统计。

它的基本性质：

- 节点本身不存储完整的单词或词组
- 从根结点到某一个节点，路径上的所有节点存储的字符连接起来，得到对应的字符串
- 每个节点的所有自节点路径都代表不同的字符

字典树运用空间换时间的思想，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。

并查集的结构和用法都比较固定，一般用来判断两个节点是不是在一颗树中。

一般包含两个操作：

- 合并节点
- 查找根结点

## 高级搜索

- 剪枝与回溯：在分部解决问题的过程中，通过试错，当通过尝试发现现有的分步答案不能得到有效正确答案的时候，取消上一步或上几步的操作，最终寻找到问题的答案。
- 双向BFS：在首尾两端同时进行广度优先搜索。
- 启发式搜索：通过判断哪些路径最有可能接近最终问题的答案，来优先执行，从而达到快速定位最终结果的方法。

## 红黑树、AVL 树

AVL 树：防止普通二叉树的不平衡状态导致低效，通过旋转的操作进行左右子树的平衡。

红黑树是一种近似平衡的二叉树，能够确保任何一个节点的左右子树的高度差小于两倍。它有如下性质：

- 每个节点都有一个颜色，红/黑。
- 根结点是黑色
- 每个叶节点都是黑色。
- 不能有相邻的红色节点。
- 从任一节点到其每个叶子结点所经过的路径都包含相同数量的黑色节点。

## 位运算

- `<<` 左移
- `>>` 右移
- `|` 按位或
- `&` 按位与
- `~` 按位取反
- `^` 按位异或

常见应用：

- 将 x 最右边的 n 位清零 `x&(~0<<n)`
- 获取 x 的第 n 位值 `(x>>n)&1`
- 获取 x 的第 n 位的幂值 `x&(1<<n)`
- 仅将第 n 位置为 1 `x|(1<<n)`
- 仅将第 n 位置为 0 `x&(~(1<<n))`
- 将 x 最高位至第 n 位(含)清零 `x&((1<<n)-1)`

## 布隆过滤器、LRU 缓存

布隆过滤器是一个很长的二进制向量和一系列随机映射函数，用于件所个元素是否在一个集合中。它的有点事空间效率和时间效率都远超过大部分类似的算法，缺点是有一定的误识别率和删除困难。

## 排序算法

- 选择排序：每次找到最小值，放到起始位置。
- 插入排序：从前到后逐步构建有序的序列，对于为排序数据，在已经排序序列中从后向前扫描，找到相应位置并插入。
- 冒泡排序：潜逃循环，每次查看相邻元素，如果逆序则交换。
- 快速排序：分治思想，取标杆 pivot，将小元素放在左边，大元素放在右边，再依次对左右两边继续进行快速排序，直到整个序列有序。
- 归并排序：把序列平分为两部分，对两个字序列分别采用归并排序，再将两个排序好的字序列合并。
- 堆排序：将元素一次插入小顶堆，再依次取出元素。
- 计数排序：计数排序要求输入的数据必须是由确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。
- 桶排序：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。
- 基数排序：按照低位先排序，然后收集。再按照高位排序，然后再收集。以此类推，直到最高位。